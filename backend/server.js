const express = require('express');
const cors = require('cors');
const axios = require('axios');
const database = require('./config/database');
const marketDataService = require('./services/marketDataService'); // Correct and single import

console.log("Starting AlgoTrade Backend Server...");

// Create Express app
const app = express();
const PORT = 3001;

// Middleware
app.use(cors());
app.use(express.json());

// AI Engine API URL with timeout
const AI_ENGINE_URL = 'http://localhost:8000';
const AI_ENGINE_TIMEOUT = 5000; // 5 seconds

// ---------------------------------------------
// Database Connection
// ---------------------------------------------
async function connectToDatabase() {
    try {
        await database.connect(); // Assuming `database` module has a connect method
        console.log('Database connected successfully');
    } catch (error) {
        console.error('FATAL: Database connection failed:', error.message);
    }
}
connectToDatabase();

// Test route
app.get('/', (req, res) => {
  res.json({
    message: 'AlgoTrade Backend Server is running!',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// Import Backtest and AI services
const backtestService = require('./services/backtestService');
const aiTradingService = require('./services/aiTradingService'); // Assuming this exists

// ðŸŸ¢ UPDATED: Include the new 'hyper_aggressive' strategy
const strategies = ['momentum', 'mean_reversion', 'rsi', 'aggressive', 'hyper_aggressive'];

// ==================== BACKTESTING APIs ====================

// Backtest a specific strategy
app.post('/api/backtest/strategy', async (req, res) => {
    try {
        const { symbol, strategy, initialCapital = 10000 } = req.body;
        
        if (!symbol || !strategy) {
            return res.status(400).json({
                success: false,
                message: 'Symbol and strategy are required'
            });
        }
        
        // Ensure strategy is valid
        if (!strategies.includes(strategy)) {
             return res.status(400).json({
                success: false,
                message: `Invalid strategy: ${strategy}. Must be one of: ${strategies.join(', ')}`
            });
        }

        console.log(`ðŸ“Š Backtesting ${strategy} strategy for ${symbol}...`);
        
        // Use the mock data generated by aiTradingService if the backend requires it
        const historicalData = await aiTradingService.getMockHistoricalData(symbol);
        const result = await backtestService.backtestStrategy(strategy, symbol, historicalData, initialCapital);
        
        res.json({
            success: true,
            data: result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error in backtesting:', error);
        res.status(500).json({
            success: false,
            message: 'Error running backtest',
            error: error.message
        });
    }
});

// Compare multiple strategies
app.post('/api/backtest/compare', async (req, res) => {
    try {
        const { symbol, initialCapital = 10000 } = req.body;
        
        if (!symbol) {
            return res.status(400).json({
                success: false,
                message: 'Symbol is required'
            });
        }

        console.log(`ðŸ“ˆ Comparing strategies for ${symbol}...`);
        
        // Use the mock data generated by aiTradingService if the backend requires it
        const historicalData = await aiTradingService.getMockHistoricalData(symbol);
        const result = await backtestService.compareStrategies(symbol, historicalData, initialCapital);
        
        res.json({
            success: true,
            data: result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error in strategy comparison:', error);
        res.status(500).json({
            success: false,
            message: 'Error comparing strategies',
            error: error.message
        });
    }
});

// Get backtest results for multiple stocks
app.post('/api/backtest/bulk', async (req, res) => {
    try {
        const { symbols, strategy = 'momentum', initialCapital = 10000 } = req.body;
        
        if (!symbols || !Array.isArray(symbols)) {
            return res.status(400).json({
                success: false,
                message: 'Symbols array is required'
            });
        }
        
        // Ensure strategy is valid
        if (!strategies.includes(strategy)) {
             return res.status(400).json({
                success: false,
                message: `Invalid strategy: ${strategy}. Must be one of: ${strategies.join(', ')}`
            });
        }

        console.log(`ðŸ“‹ Bulk backtesting ${strategy} for ${symbols.length} stocks...`);
        
        const results = [];
        for (const symbol of symbols) {
            try {
                // Use the mock data generated by aiTradingService if the backend requires it
                const historicalData = await aiTradingService.getMockHistoricalData(symbol);
                const result = await backtestService.backtestStrategy(strategy, symbol, historicalData, initialCapital);
                results.push(result);
            } catch (error) {
                console.error(`Error backtesting ${symbol}:`, error);
                results.push({ symbol, error: error.message });
            }
        }
        
        // Sort by performance
        results.sort((a, b) => (b.metrics?.totalReturn || 0) - (a.metrics?.totalReturn || 0));
        
        res.json({
            success: true,
            data: results,
            strategy,
            count: results.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error in bulk backtesting:', error);
        res.status(500).json({
            success: false,
            message: 'Error in bulk backtesting',
            error: error.message
        });
    }
});

// Test endpoint to verify backtest service is working
app.get('/api/backtest/test', async (req, res) => {
    try {
        console.log('ðŸ§ª Testing backtest service...');
        
        // Simple test without database dependency
        const mockData = {
            close: [100, 102, 101, 105, 103, 108, 107, 110, 109, 112],
            open: [99, 101, 100, 104, 102, 107, 106, 109, 108, 111],
            high: [101, 103, 102, 106, 104, 109, 108, 111, 110, 113],
            low: [98, 100, 99, 103, 101, 106, 105, 108, 107, 110],
            volume: [1000000, 1200000, 900000, 1500000, 1100000, 1300000, 1000000, 1400000, 1200000, 1600000],
            timestamp: ['2025-11-17', '2025-11-18', '2025-11-19', '2025-11-20', '2025-11-21', '2025-11-24', '2025-11-25', '2025-11-26', '2025-11-27', '2025-11-28']
        };
        
        const result = await backtestService.backtestStrategy('hyper_aggressive', 'TEST', mockData, 10000);
        
        res.json({
            success: true,
            message: 'Backtest service is working!',
            data: result
        });
    } catch (error) {
        console.error('Backtest test error:', error);
        res.status(500).json({
            success: false,
            message: 'Backtest service error',
            error: error.message
        });
    }
});

// ==================== AI TRADING APIs ====================

// Get AI trading signal for a single stock
app.get('/api/ai/signal/:symbol', async (req, res) => {
    try {
        const { symbol } = req.params;
        console.log(`ðŸ¤– Generating AI signal for: ${symbol}`);
        
        const signal = await aiTradingService.generateSignals(symbol, await aiTradingService.getMockHistoricalData(symbol));
        
        res.json({
            success: true,
            data: signal,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error generating AI signal:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating AI trading signal',
            error: error.message
        });
    }
});

// Get AI signals for multiple stocks
app.post('/api/ai/signals/bulk', async (req, res) => {
    try {
        const { symbols } = req.body;
        
        if (!symbols || !Array.isArray(symbols)) {
            return res.status(400).json({
                success: false,
                message: 'Symbols array is required'
            });
        }

        console.log(`ðŸ¤– Generating bulk AI signals for: ${symbols.join(', ')}`);
        
        const signals = await aiTradingService.getBulkSignals(symbols);
        
        res.json({
            success: true,
            data: signals,
            count: signals.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error generating bulk AI signals:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating bulk AI signals',
            error: error.message
        });
    }
});

// Get AI-recommended stocks (top picks)
app.get('/api/ai/recommendations', async (req, res) => {
    try {
        const popularStocks = ['RELIANCE', 'TCS', 'INFY', 'HDFCBANK', 'ICICIBANK', 'HINDUNILVR', 'ITC', 'SBIN'];
        
        console.log('ðŸ¤– Generating AI stock recommendations...');
        const signals = await aiTradingService.getBulkSignals(popularStocks);
        
        // Filter for BUY recommendations and sort by confidence
        const recommendations = signals
            .filter(signal => signal.signal === 'BUY')
            .sort((a, b) => b.confidence - a.confidence)
            .slice(0, 5); // Top 5 recommendations
        
        res.json({
            success: true,
            data: recommendations,
            count: recommendations.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error generating AI recommendations:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating AI recommendations',
            error: error.message
        });
    }
});

// Import PortfolioManager Instance
// NOTE: Since PortfolioManager.js exports an already instantiated instance (module.exports = new PortfolioManager()), 
// we use require without the class reference.
const portfolioManager = require('./portfolioManager'); 

// ---------------------------------------------
// Portfolio Routes (AWAIT ADDED WHERE NECESSARY)
// ---------------------------------------------

app.get('/api/portfolio', async (req, res) => {
    try {
        // NOTE: The portfolio manager now fetches real prices internally, 
        // passing dummy prices here is vestigial but harmless.
        const portfolioSummary = await portfolioManager.getPortfolioSummary(); 
        
        res.json({
            success: true,
            data: portfolioSummary,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching portfolio:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch portfolio data',
            details: error.message
        });
    }
});

app.post('/api/portfolio/trade', async (req, res) => {
    try {
        let { symbol, action, quantity } = req.body;
        quantity = parseFloat(quantity);
        
        if (!symbol || !action || isNaN(quantity) || quantity <= 0) {
            // Price check is removed as PM fetches it.
            return res.status(400).json({
                success: false,
                error: 'Invalid or missing fields. Ensure symbol, action, and positive numeric quantity are provided.'
            });
        }

        let result;
        const upperAction = action.toUpperCase();

        // The portfolio manager handles fetching the current price internally.
        if (upperAction === 'BUY') {
            result = await portfolioManager.buyStock(symbol, quantity);
        } else if (upperAction === 'SELL') {
            result = await portfolioManager.sellStock(symbol, quantity);
        } else {
            return res.status(400).json({
                success: false,
                error: 'Invalid action. Use BUY or SELL'
            });
        }
        
        // The result is the updated summary from the PM
        res.json({
            success: true,
            message: `${upperAction} trade executed successfully.`,
            portfolio: result 
        });

    } catch (error) {
        console.error('Error executing trade:', error);
        res.status(500).json({
            success: false,
            error: 'Trade execution failed',
            details: error.message
        });
    }
});

// Reset portfolio route
app.post('/api/portfolio/reset', async (req, res) => {
    try {
        let { capital } = req.body;
        capital = parseFloat(capital) || 1000; 

        const summary = await portfolioManager.resetPortfolio(capital);
        
        res.json({
            success: true,
            message: `Portfolio reset successfully with capital: ${capital}`,
            summary: summary
        });
    } catch (error) {
        console.error('Error resetting portfolio:', error);
        res.status(500).json({
            success: false,
            message: 'Error resetting portfolio',
            error: error.message
        });
    }
});

// Get portfolio summary
app.get('/api/portfolio/summary', async (req, res) => {
    try {
        const summary = await portfolioManager.getPortfolioSummary();
        res.json({
            success: true,
            summary: summary
        });
    } catch (error) {
        console.error('Error getting portfolio summary:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting portfolio summary',
            error: error.message
        });
    }
});

app.get('/api/portfolio/history', (req, res) => {
    try {
        res.json({
            success: true,
            data: {
                trades: portfolioManager.portfolio.transactions,
                totalTrades: portfolioManager.portfolio.transactions.length
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching trade history:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch trade history',
            details: error.message
        });
    }
});

// Test portfolio manager endpoint
app.get('/api/test/portfolio', async (req, res) => {
    try {
        console.log('ðŸ§ª Testing portfolio manager...');
        
        let portfolio;
        try {
            portfolio = await portfolioManager.getPortfolioSummary();
            console.log('âœ… Portfolio manager working:', portfolio ? 'Yes' : 'No');
        } catch (error) {
            console.log('âŒ Portfolio manager error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Portfolio manager not working',
                error: error.message
            });
        }
        
        res.json({
            success: true,
            portfolio: portfolio,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('Test portfolio error:', error);
        res.status(500).json({
            success: false,
            message: 'Test failed',
            error: error.message
        });
    }
});

const autoTradingService = require('./services/autoTradingService');

// ==================== AUTOMATED TRADING APIs ====================

// Start automated trading
app.post('/api/auto-trading/start', async (req, res) => {
    try {
        const { symbols } = req.body;
        const result = await autoTradingService.startTrading(symbols);
        
        res.json({
            success: true,
            ...result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error starting auto trading:', error);
        res.status(500).json({
            success: false,
            message: 'Error starting automated trading',
            error: error.message
        });
    }
});

// Stop automated trading
app.post('/api/auto-trading/stop', async (req, res) => {
    try {
        const result = autoTradingService.stopTrading();
        
        res.json({
            success: true,
            ...result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error stopping auto trading:', error);
        res.status(500).json({
            success: false,
            message: 'Error stopping automated trading',
            error: error.message
        });
    }
});

// Get trading status
app.get('/api/auto-trading/status', async (req, res) => {
    try {
        const status = autoTradingService.getStatus();
        
        res.json({
            success: true,
            data: status,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error getting trading status:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting trading status',
            error: error.message
        });
    }
});

// Update trading settings
app.post('/api/auto-trading/settings', async (req, res) => {
    try {
        const { settings } = req.body;
        const result = autoTradingService.updateSettings(settings);
        
        res.json({
            success: true,
            ...result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error updating trading settings:', error);
        res.status(500).json({
            success: false,
            message: 'Error updating trading settings',
            error: error.message
        });
    }
});

// Force test trades endpoint
app.post('/api/auto-trading/test-trades', async (req, res) => {
    try {
        console.log('ðŸ§ª FORCING TEST TRADES...');
        
        const portfolio = await portfolioManager.getPortfolioSummary();
        let executedTrades = 0;
        
        // Create high-confidence test signals
        const testSignals = [
            { symbol: 'RELIANCE', signal: 'BUY', confidence: 85 },
            { symbol: 'TCS', signal: 'BUY', confidence: 80 },
            { symbol: 'ITC', signal: 'SELL', confidence: 75 }
        ];
        
        for (const signal of testSignals) {
            try {
                const trade = await autoTradingService.executeTrade(signal, portfolio);
                if (trade) {
                    executedTrades++;
                    console.log(`âœ… TEST TRADE EXECUTED: ${signal.signal} ${signal.symbol}`);
                }
            } catch (error) {
                console.log(`âŒ Test trade failed for ${signal.symbol}:`, error.message);
            }
        }
        
        res.json({
            success: true,
            message: `Executed ${executedTrades} test trades`,
            executedTrades,
            portfolio: await portfolioManager.getPortfolioSummary(),
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('Error in test trades:', error);
        res.status(500).json({
            success: false,
            message: 'Error executing test trades',
            error: error.message
        });
    }
});

// ==================== ENHANCED PORTFOLIO APIs ====================

// Get portfolio summary with real-time valuation
app.get('/api/portfolio/summary/live', async (req, res) => {
    try {
        console.log('ðŸ“Š Generating live portfolio summary...');
        const summary = await portfolioManager.getPortfolioSummary();
        
        res.json({
            success: true,
            data: summary,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error generating live portfolio summary:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating portfolio summary',
            error: error.message
        });
    }
});

// Enhanced buy endpoint (uses current market price)
app.post('/api/portfolio/buy', async (req, res) => {
    try {
        const { symbol, quantity } = req.body;
        
        if (!symbol || !quantity) {
            return res.status(400).json({
                success: false,
                message: 'Symbol and quantity are required'
            });
        }

        console.log(`ðŸ›’ Buy order: ${quantity} ${symbol}`);
        const result = await portfolioManager.buyStock(symbol.toUpperCase(), parseInt(quantity));
        
        res.json({
            success: true,
            message: `Successfully bought ${quantity} shares of ${symbol}`,
            data: result
        });
    } catch (error) {
        console.error('Error buying stock:', error);
        res.status(500).json({
            success: false,
            message: 'Error buying stock',
            error: error.message
        });
    }
});

// Enhanced sell endpoint (uses current market price)
app.post('/api/portfolio/sell', async (req, res) => {
    try {
        const { symbol, quantity } = req.body;
        
        if (!symbol || !quantity) {
            return res.status(400).json({
                success: false,
                message: 'Symbol and quantity are required'
            });
        }

        console.log(`ðŸ·ï¸ Sell order: ${quantity} ${symbol}`);
        const result = await portfolioManager.sellStock(symbol.toUpperCase(), parseInt(quantity));
        
        res.json({
            success: true,
            message: `Successfully sold ${quantity} shares of ${symbol}`,
            data: result
        });
    } catch (error) {
        console.error('Error selling stock:', error);
        res.status(500).json({
            success: false,
            message: 'Error selling stock',
            error: error.message
        });
    }
});

// Portfolio analytics endpoint
app.get('/api/portfolio/analytics', async (req, res) => {
    try {
        console.log('ðŸ“ˆ Generating portfolio analytics...');
        const analytics = await portfolioManager.getPortfolioAnalytics();
        
        res.json({
            success: true,
            data: analytics,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error generating portfolio analytics:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating portfolio analytics',
            error: error.message
        });
    }
});

// Get transaction history
app.get('/api/portfolio/transactions', async (req, res) => {
    try {
        const { limit } = req.query;
        let transactions = portfolioManager.portfolio.transactions;
        
        // Sort by timestamp (newest first)
        transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Apply limit if provided
        if (limit) {
            transactions = transactions.slice(0, parseInt(limit));
        }
        
        res.json({
            success: true,
            data: transactions,
            count: transactions.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching transactions:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching transactions',
            error: error.message
        });
    }
});

// ---------------------------------------------
// Market Data Routes (Consolidated & Cleaned)
// ---------------------------------------------

// 1. Get current price for a single stock
app.get('/api/stocks/:symbol/price', async (req, res) => {
    try {
        const { symbol } = req.params;
        const price = await marketDataService.getCurrentPrice(symbol.toUpperCase());
        
        res.json({
            success: true,
            symbol: symbol.toUpperCase(),
            price: price,
            currency: 'INR',
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching stock price:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching stock price',
            error: error.message
        });
    }
});

// 2. Get historical data for a stock
app.get('/api/stocks/:symbol/history', async (req, res) => {
    try {
        const { symbol } = req.params;
        const { period = '1mo' } = req.query;
        
        const historicalData = await marketDataService.getHistoricalData(symbol.toUpperCase(), period);
        
        res.json({
            success: true,
            data: historicalData,
            period: period,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching historical data:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching historical data',
            error: error.message
        });
    }
});

// 3. Bulk get prices for multiple stocks
app.post('/api/stocks/prices/bulk', async (req, res) => { // Renamed for clarity
    try {
        const { symbols } = req.body;
        
        if (!symbols || !Array.isArray(symbols)) {
            return res.status(400).json({
                success: false,
                message: 'Symbols array is required in request body'
            });
        }
        
        const prices = await marketDataService.getBulkPrices(symbols.map(s => s.toUpperCase()));
        
        res.json({
            success: true,
            data: prices,
            count: prices.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching bulk prices:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching bulk prices',
            error: error.message
        });
    }
});

// 4. Get popular Indian stocks
app.get('/api/stocks/popular/indian', async (req, res) => {
    try {
        const popularStocks = [
            'RELIANCE', 'TCS', 'HDFCBANK', 'INFY', 'HINDUNILVR',
            'HDFC', 'ICICIBANK', 'KOTAKBANK', 'ITC', 'SBIN',
            'BHARTIARTL', 'LT', 'ASIANPAINT', 'HCLTECH', 'MARUTI',
            'SUNPHARMA', 'TITAN', 'AXISBANK', 'ULTRACEMCO', 'M&M'
        ];
        
        const stockData = await marketDataService.getBulkPrices(popularStocks);
        
        res.json({
            success: true,
            data: stockData,
            count: stockData.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error fetching popular stocks:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching popular stocks',
            error: error.message
        });
    }
});

// ---------------------------------------------
// Health & AI Engine Routes
// ---------------------------------------------

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'backend',
    timestamp: new Date().toISOString()
  });
});

// Enhanced AI engine health check
app.get('/ai-health', async (req, res) => {
  try {
    console.log('Checking AI engine health...');
    const response = await axios.get(`${AI_ENGINE_URL}/health`, {
      timeout: AI_ENGINE_TIMEOUT
    });
    
    res.json({
      ai_engine_status: 'connected',
      ai_response: response.data,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('AI engine health check failed:', error.message);
    res.status(503).json({ 
      ai_engine_status: 'disconnected',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Fallback sectors data
const FALLBACK_SECTORS = {
    'Technology & IT': [
        {
          symbol: 'TCS.NS',
          name: 'Tata Consultancy Services Limited',
          current_price: 3450.25,
          change_percent: 1.2,
          volume: 1876543,
          market_cap: 1250000000000,
          ai_signal: 'BUY',
          ai_confidence: 85.5,
          signal_strength: 2.1,
          rsi: 65.3
        },
        {
          symbol: 'INFY.NS',
          name: 'Infosys Limited',
          current_price: 1650.75,
          change_percent: 0.8,
          volume: 2345678,
          market_cap: 680000000000,
          ai_signal: 'HOLD',
          ai_confidence: 72.3,
          signal_strength: 0.5,
          rsi: 58.7
        }
      ],
      'Banking & Financial': [
        {
          symbol: 'HDFCBANK.NS',
          name: 'HDFC Bank Limited',
          current_price: 1650.50,
          change_percent: -0.5,
          volume: 3456789,
          market_cap: 950000000000,
          ai_signal: 'BUY',
          ai_confidence: 78.9,
          signal_strength: 1.8,
          rsi: 45.2
        },
        {
          symbol: 'ICICIBANK.NS',
          name: 'ICICI Bank Limited',
          current_price: 980.25,
          change_percent: 1.1,
          volume: 4567890,
          market_cap: 650000000000,
          ai_signal: 'BUY',
          ai_confidence: 82.1,
          signal_strength: 2.3,
          rsi: 62.8
        }
      ],
      'Energy & Oil & Gas': [
        {
          symbol: 'RELIANCE.NS',
          name: 'Reliance Industries Limited',
          current_price: 2456.75,
          change_percent: 0.3,
          volume: 3456789,
          market_cap: 1660000000000,
          ai_signal: 'HOLD',
          ai_confidence: 65.8,
          signal_strength: 0.2,
          rsi: 55.4
        }
      ]
};

// Proxy to AI Engine - Get sectors data with robust error handling
app.get('/api/sectors', async (req, res) => {
  const startTime = Date.now();
  
  try {
    console.log('Fetching sectors data from AI engine...');
    
    const response = await axios.get(`${AI_ENGINE_URL}/sectors`, {
      timeout: AI_ENGINE_TIMEOUT
    });
    
    const responseTime = Date.now() - startTime;
    console.log(`âœ… Successfully fetched sectors data (${responseTime}ms)`);
    
    const aiData = response.data.sectors || response.data;
    
    res.json({
      success: true,
      data: {
          sectors: aiData,
          last_updated: new Date().toISOString()
      },
      served_by: 'ai_engine',
      response_time_ms: responseTime,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error(`âŒ Error fetching sectors (${responseTime}ms):`, error.message);
    
    // Use fallback data immediately
    console.log('ðŸ”„ Using fallback sectors data');
    
    res.json({
      success: true, 
      data: {
        sectors: FALLBACK_SECTORS,
        last_updated: new Date().toISOString(),
        served_by: 'fallback'
      },
      served_by: 'fallback',
      response_time_ms: responseTime,
      note: 'Using fallback data - AI engine unavailable or timed out',
      timestamp: new Date().toISOString()
    });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`Backend Server running on http://localhost:${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
  console.log(`AI Health check: http://localhost:${PORT}/ai-health`);
  console.log(`Stocks API: http://localhost:${PORT}/api/sectors`);
});